# gdb-guide-ru

### Общее описание
Я буду разбирать отладку в `gdb` (*GNU Debugger*) в *консоли* на примере языка Си. Я не буду рассказывать как установить отладчик и компилятор.

**Важно понимать**, что продукты от `llvm` содержат похожие флаги и команды, чтобы упростить переход на них пользователей GNU программ, но всё же разница есть. Вы точно можете использовать компилятор `clang` вместо `gcc`, и я не думаю, что у вас будет совершенно иной опыт при использовании отладчика `lldb`. Про различия команд можно почитать [тут](https://lldb.llvm.org/use/map.html)

### Основные команды GDB
- **break** или **b** - создание точки останова;
- **list** или **l** - листинг программы с определённого места
- **info** или **i** - вывести информацию, доступные значения: break, registers, frame, locals, args;
- **run** или **r** - запустить программу;
- **continue** или **c** - продолжить выполнение программы после точки останова;
- **step** или **s** - выполнить следующую строчку программы с заходом в функцию;
- **next** или **n** - выполнить следующую строчку без захода в функцию;
- **print** или **p** - вывести значение переменной;
- **backtrace** или **bt** - вывести стек вызовов;
- **x** - просмотр содержимого памяти по адресу;
- **ptype** - просмотр типа переменной;
- **h** или **help** - просмотр справки по команде;
- **q** или **quit**, `Ctrl`+`d` - выход из отладчика.

#### Навыки:
1. установить `флаги компилятора` для отладочной версии
2. использовать `макросы дебага`
3. поставить `точку останова`
4. *запустить* программу + записывать и читать *данные из файла* при отладке
5. *выходить* из дебаггера
6. *продолжить* выполнение программы после срабатывания точки останова
7. *просмотреть* точки останова
8. *удалить* точку останова
9. *посмотреть значение* переменной
10. *просмотреть* все используемые `локальные переменные`
11. *просмотреть* `аргументы функции`
12. просматривать `место остановки` программы
13. просматривать `листинг` программы
14. ставить `точку останова` *на функцию* или на строку *в файле*
15. *убить процесс* запущенной программы
16. *поменять значение* переменной во время работы программы
17. установить `условие срабатывания` точки останова
18. *игнорировать* некоторое количество попаданий в точку останова
19. под отладкой записывать значение по `указателю`
20. под отладкой просматривать все `поля структуры` + менять поля структуры
21. под отладкой обращаться по `указателю на структуру`
22. просматривать `массив` под отладкой и менять значение его элементов
23. *пошагово* выполнять программу
24. *пошагово* выполнять программу, входя в код `функций` и `процедур`
25. *выполнить* определённое количество `строк кода`
26. посмотреть `стек вызовов` функций
27. *узнать* `тип переменной`
28. ставить `точки останова` *относительно* текущего положения
29. *выключать* и *включать* точки останова
30. вывести `дизассемблер` программы
31. *отслеживать* изменение значения `переменной`
32. поставить `точку наблюдения` (watchpoint)
33. *завершить выполнение* текущей функции и выйти из неё
34. отладка в `layout` режиме + как выйти из него
35. *пошагово* выполнять ассемблерные инструкции
36. *подключаться* к запущенному `процессу` для отладки
37. *дополнительные* команды

---

1. установить `флаги компилятора` для отладочной версии
- Для того, чтобы скомпилировать программу в режиме дебага, нужно установить для `gcc` следующие `флаги`:
	- `-g` или `-ggdb` (указывает, что дебаг будет производиться `gdb`, но это не имеет значения)
	- `-g0`, `-g1`, `-g2`, `-g3` - это уровни отладочной информации, где `-g3` самый высокий.
*Пример*:
```sh
gcc main.c -o main.out -g
```
Чтобы *запустить* исполняемый файл *под отладкой* нужно:
```sh
gdb ./main.out
```
Также *лучше отключать оптимизацию* на этапе отладки, чтобы код работал без правок компилятора. То есть не использовать уровень оптимизации `-o0` или вовсе ничего не писать.
- Для `gdb` тоже есть флаги: `-silent` убирает ненужную *информацию о gdb* при запуске отладчика
*Пример*:
```
gdb -silent ./main.out
```


2. использовать `макросы дебага`, чтобы определить какой режим работы приложения установлен
**Описание кода**: Компиляторы C и C++ сами по себе не добавляют в код специальные макросы, которые явно указывают, что код скомпилирован в режиме отладки. Обычно для этого в проектах вручную или через систему сборки определяется макрос, например, `DEBUG` или `NDEBUG`, который можно использовать для условной компиляции кода отладки.
- Вот как это можно сделать (`-D` значит `#define`):
```sh
gcc main.c -o main.out -g -DDEBUG
```
**Далее эти строчки в main.c будут пропускаться**: 
```c
#include <stdio.h> // ввод и вывод в консоль

```
**Код на C**:
```c
int main() {
	#ifdef DEBUG
		printf("Hello debug!\n");
	#else
		printf("Hello release!\n");
	#endif
	
	return 0;
}
```
**Вывод в консоль**:
```
Hello debug!
```

---
#### Начнём веселье
Посмотреть справку:
- Перед началом разбора конкретных команд нужно сказать, что узнать подробнее о командах GDB можно, написав:
```sh
help
```
Для этого нужно запустить GDB без файлов:
```sh
gdb
```
- можно узнать о командах в интересующем разделе:
```sh
help breakpoints
```
- можно узнать о конкретной команде:
```sh
help break
```
Нужно понимать, что в справке могут быть записаны не все сокращения команды. До некоторых сокращений нужно додумываться самому

**Описание кода**: по-началу мы будем тестировать этот код.
**Код на C**:
```c
int main() {
	int i = 7;
	
	printf("\n");
	printf("%d\n", i);
	printf("\n");
	
	return 0;
}
```
**Вывод в консоль**:
```

7

```

3. поставить `точку останова`
**Описание**: Чтобы поставить её, нужно использовать команду `break, brea, bre, br, b` и *указать* `номер строки` до которой программа дойдёт и остановить свою работу. Ставить точки останова можно *во время дебага*.
**Команды (gdb)**:
```sh
b 7
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1186: file main.c, line 7.
```

4. *запустить* программу
- **Описание**: продолжим предыдущий пример, используя команду `run, r`. После этого воспользуемся `c` (*продолжить*) и `q` (*закрыть отладчик*), чтобы выйти из `gdb`.
**Команда (gdb)**:
```
r
```
**Вывод в консоль**:
```sh
Starting program: /home/.../main.out
[Thread debugging using libthread_db enabled]
Using host libthread_db library "/lib/x86_64-linux-gnu/libthread_db.so.1".


Breakpoint 1, main () at main.c:7
7		printf("%d\n", i);
```
- **Описание**: программа может выводиться не в консоль, а в файл с помощью `r > [имя файла]`. При этом содержимое файла сотрётся перед записью.
**Команда (gdb)**: `run` может принимать *на вход*: *файл* откуда берутся данные ввода и *файл* куда записать вывод программы.
Например как записать вывод программы в файл `output.txt` (если файла нет, то он создастся сам):
```sh
r > output.txt
```
**Содержимое файла**:
```

7

```
- **Описание**: программа также может выводиться в файл с помощью `r >> [имя файла]`. При этом содержимое файла останется и запись начнётся с конца файла. Имя файла, конечно, может быть любым, не обязательно `output`. В `gdb`, как видно из команд ниже, сохраняется состояние  ввода и вывода, поэтому постоянно указывать `>> output.txt` не обязательно.
**Команда (gdb)**:
```sh
r >> output.txt
r
r
```
**Содержимое файла**: (предыдущая `7` там осталась после прошлого вызова `r > output.txt`)
```

7


7


7


7

```
- **Описание**: программа может получать ввод не из консоли от пользователя, а из файла с помощью `r < [имя файла]`. Чтобы это увидеть перепишем программу.
**Код на C**:
```c
int main() {
	int i = 7;
	
	scanf("%d", &i);
	printf("\n");
	printf("%d\n", i);
	printf("\n");
	
	return 0;
}
```
**Команда (gdb)**:
```
r < input.txt
```
**Вывод в консоль**:
```

147

```
- **Описание**: теперь совместим полученные знания и напишем команду, которая не взаимодействует с консолью, берёт данные из файла и записывает их в файл.
**Команда (gdb)**:
```
r < input.txt > output.txt
```
**Содержимое файла input.txt**:
```
147
```
**Содержимое файла output.txt**:
```

147

```

5. *выходить* из дебаггера
**Описание**: Чтобы выйти из дебаггера, нужно использовать команду `quit, exit, q` или нажать сочетание клавиш `Ctrl`+`d`. Если вы не завершили работу программы перед выходом, то вас спросят, хотите ли вы прервать процесс программы (`y` - хочу, `n`- не хочу и не буду выходить из дебаггера).
Далее будем разбирать примеры со второй программой из начала.
**Команда (gdb)**:
```
r
q
```
**Вывод в консоль**:
```

7

```

6. *продолжить* выполнение программы после срабатывания точки останова
**Описание**: чтобы продолжить выполнение программы после срабатывания точки останова, нужно воспользоваться командой `continue, fg, c`.
**Команды (gdb)**:
```sh
b 7
r
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x555555555186: file main.c, line 7.

Breakpoint 1, main () at main.c:7
7		printf("%d\n", i);
Continuing.
7

```

**Описание кода**: Напишем программу, в которой точка останова будет в цикле
**Код на C**:
```c
int main() {
	int i = 7;
	
	printf("\n");
	for(int j = 0; j < 5; j++)
		printf("%d\n", i);
	printf("\n");
	
	return 0;
}
```
**Описание**:  если поставить точку останова, которая будет срабатывать несколько раз, например в цикле `for()`, то выйти из неё можно, указав сколько раз нужно проигнорировать эту точку останова при помощи команды `continue, fg, c [количество игнорирований]`.
**Команды (gdb)**:
```sh
b 8
r
continue 3
continue 3
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x118f: file main.c, line 8.

Starting program: ...

Breakpoint 1, main () at main.c:8
8			printf("%d\n", i);

Will ignore next 2 crossings of breakpoint 1.  Continuing.
7
7
7

Breakpoint 1, main () at main.c:8
8			printf("%d\n", i);

Will ignore next 2 crossings of breakpoint 1.  Continuing.
7
7

```

7. *просмотреть* точки останова
**Описание кода**: изменим код, добавив самописную функцию `myfunc()` внутри `main()`:
**Код на C**:
```c
int myfunc() {
	printf("\n");
	return 9;
}

int main() {
	int i = 7;
	
	printf("\n");
	printf("%d\n", i);
	printf("%d\n", myfunc());
	printf("\n");
	
	return 0;
}
```
**Описание**: с помощью команды `info, inf, i [b]`, можно узнать состояние всех точек останова. По номерам их потом можно будет удалить.
**Команда (gdb)**:
```
b 5
b 13
r
info b
c
info b
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x117b: file main.c, line 5.
Breakpoint 2 at 0x11b8: file main.c, line 13.

7

Breakpoint 2, main () at main.c:13
13		printf("%d\n", myfunc());

Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000055555555517b in myfunc at main.c:5
2       breakpoint     keep y   0x00005555555551b8 in main at main.c:13
	breakpoint already hit 1 time
Continuing.


Breakpoint 1, myfunc () at main.c:5
5		return 9;


Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000055555555517b in myfunc at main.c:5
	breakpoint already hit 1 time
2       breakpoint     keep y   0x00005555555551b8 in main at main.c:13
	breakpoint already hit 1 time
Continuing.
9

```

8. *удалить* точку останова
- **Описание**: используя команды выше, узнаём номера точек останова и удаляем ненужные с помощью команды `delete, del, d (номер точки)`
**Команда (gdb)**:
```
b 5
b 11
b 12
b 13
b 14
info b
del 1
// продолжение дальше
```
**Вывод в консоль**:
```
// ... тут инфа, что точки созданы

Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000000117b in myfunc at main.c:5
2       breakpoint     keep y   0x0000000000001195 in main at main.c:11
3       breakpoint     keep y   0x000000000000119f in main at main.c:12
4       breakpoint     keep y   0x00000000000011b8 in main at main.c:13
5       breakpoint     keep y   0x00000000000011d8 in main at main.c:14

Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x0000000000001195 in main at main.c:11
3       breakpoint     keep y   0x000000000000119f in main at main.c:12
4       breakpoint     keep y   0x00000000000011b8 in main at main.c:13
5       breakpoint     keep y   0x00000000000011d8 in main at main.c:14
```
- **Описание**: если нужно удалить сразу несколько точек останова, то можно указать их через тире: `номер точки(начало)`-`номер точки(конец)`
**Команда (gdb)**:
```
del 3-4
i b
q
```
**Вывод в консоль**:
```
Num     Type           Disp Enb Address            What
2       breakpoint     keep y   0x0000000000001195 in main at main.c:11
5       breakpoint     keep y   0x00000000000011d8 in main at main.c:14
```

9. *посмотреть значение* переменной
- **Описание**: чтобы вывести значение переменной, нужно воспользоваться командой `print, inspect, p [имя переменной]`. Поставим точку останова и выведем значение переменной `i`.
**Команда (gdb)**:
```
b 11
r
p i
c
q
```
**Вывод в консоль**:
```
Breakpoint 1, main () at main.c:11
11		printf("\n");

$1 = 7
Continuing.

7

9

```
- **Описание**: просмотреть значение переменной можно не только в десятичном виде. Используя команду `print/[система счисления] [имя переменной]`, можно указать тип выводимых данных с помощью таких модификаторов:
- **o** - восьмеричный;
- **x** - шестнадцатеричный;
- **z** - шестнадцатеричный со всеми нулями слева;
- **d** - десятичный;
- **u** - десятичный без знака;
- **t** - двоичный;
- **f** - число с плавающей точкой;
- **a** - адрес;
- **i** - инструкция процессора;
- **с** - символ;
- **s** - строка.
Также можно указать размер выводимого блока: (не знаю как это работает)
- **b** - байт;
- **h** - полуслово (два байта);
- **w** - слово (четыре байта);
- **g** - восемь байт;
С помощью команды `p/x` выведем значение переменной `i` в шестнадцатеричном представлении.
**Команды (gdb)**:
```sh
b 11
r
p/x i
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1195: file main.c, line 11.

Starting program: ...

Breakpoint 1, main () at main.c:11
11		printf("\n");

$1 = 0x7

Continuing.

7

9

```

10. *просмотреть* все используемые `локальные переменные`
**Описание**: чтобы вывести значения переменных в текущей области видимости, нужно воспользоваться командой `info, inf, i [locals, loc, lo]`.
**Команда (gdb)**:
```
b 11
r
info locals
c
q
```
**Вывод в консоль**:
```
Breakpoint 1, main () at main.c:11
11		printf("\n");

i = 7
Continuing.

7

9

```

11. *просмотреть* `аргументы функции`
**Описание кода**: напишем свою функцию `myfunc()`, в которой  попробуем узнать значения переменных, подаваемых ей на вход. Для этого воспользуемся командой `info args`.
**Код на C**:
```c
int myfunc(char symbol, int a) {
	printf("%c\n", symbol);
	return a;
}

int main() {
	int i = 7;
	
	printf("\n");
	printf("%d\n", i);
	printf("%d\n", myfunc('M', 9));
	printf("\n");
	
	return 0;
}
```
**Описание**: поставим точку останова внутри `myfunc()` и просмотрим значения переменных, принимаемых функцией.
**Команда (gdb)**:
```
b 5
r
info args
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1197: file main.c, line 5.
Starting program: ...

7
M

Breakpoint 1, myfunc (symbol=77 'M', a=9) at main.c:5
5		return a;

symbol = 77 'M'
a = 9

Continuing.
9

```

12. просматривать `место остановки` программы
**Описание**: используя код предыдущей программы, просмотрим часть кода, где остановилась программа. Для этого воспользуемся командой `list, l`.
**Команда (gdb)**:
```
b 14
r
list
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11f7: file main.c, line 14.

Starting program: ...

7
M
9

Breakpoint 1, main () at main.c:14
14		printf("\n");

9		int i = 7;
10		
11		printf("\n");
12		printf("%d\n", i);
13		printf("%d\n", myfunc('M', 9));
14		printf("\n");
15		
16		return 0;
17	}

Continuing.
```

13. просматривать `листинг` программы
- **Описание**: чтобы просмотреть часть кода программы, нужно воспользоваться командой `list, l`. Если программа ещё не запущена, то код будет выводиться с начала файла по частям. Заметьте, что для листинга запускать программу не обязательно. Давайте выведем весь код программы, воспользовавшись командой `list` несколько раз.
**Команда (gdb)**:
```
l
l
l
q
```
**Вывод в консоль**:
```
1	#include <stdio.h> // ввод и вывод в консоль
2	
3	int myfunc(char symbol, int a) {
4		printf("%c\n", symbol);
5		return a;
6	}
7	
8	int main() {
9		int i = 7;
10		

11		printf("\n");
12		printf("%d\n", i);
13		printf("%d\n", myfunc('M', 9));
14		printf("\n");
15		
16		return 0;
17	}

Line number 18 out of range; main.c has 17 lines.
```
- **Описание**: У команды `list` есть фиксированное количество строк, которое она выводит. По умолчанию это число `10`. Чтобы в этом убедиться, воспользуемся командой `show, info set [listsize]`.
**Команда (gdb)**:
```
show listsize
info set listsize
```
**Вывод в консоль**:
```
Number of source lines gdb will list by default is 10.
Number of source lines gdb will list by default is 10.
```

- **Описание**: Чтобы изменить это значение по умолчанию, нужно воспользоваться командой `set listzize [кол-во строк]`. Если нужно выводить сразу всю программу, то воспользуйтесь командой `set listzize [unlimited]`. Что значит `l 1`, я объясню дальше.
**Команда (gdb)**:
```
set listsize 15
info set listsize
l
set listsize unlimited
info set listsize
l 1
q
```
**Вывод в консоль**:
```
Number of source lines gdb will list by default is 15.

1	#include <stdio.h> // ввод и вывод в консоль
2	
3	int myfunc(char symbol, int a) {
4		printf("%c\n", symbol);
5		return a;
6	}
7	
8	int main() {
9		int i = 7;
10		
11		printf("\n");
12		printf("%d\n", i);
13		printf("%d\n", myfunc('M', 9));
14		printf("\n");
15		

Number of source lines gdb will list by default is unlimited.

1	#include <stdio.h> // ввод и вывод в консоль
2	
3	int myfunc(char symbol, int a) {
4		printf("%c\n", symbol);
5		return a;
6	}
7	
8	int main() {
9		int i = 7;
10		
11		printf("\n");
12		printf("%d\n", i);
13		printf("%d\n", myfunc('M', 9));
14		printf("\n");
15		
16		return 0;
17	}
```
- **Описание**: Чтобы явно указать с какой строки программы мы хотим посмотреть код, можно воспользоваться командой `l [номер строки]`. При этом указанная строка будет находиться в центре просматриваемой области кода.
**Команда (gdb)**:
```
l 5
l 10
q
```
**Вывод в консоль**:
```
1	#include <stdio.h> // ввод и вывод в консоль
2	
3	int myfunc(char symbol, int a) {
4		printf("%c\n", symbol);
5		return a;
6	}
7	
8	int main() {
9		int i = 7;
10		

5		return a;
6	}
7	
8	int main() {
9		int i = 7;
10		
11		printf("\n");
12		printf("%d\n", i);
13		printf("%d\n", myfunc('M', 9));
14		printf("\n");
```
- **Описание**: Чтобы явно указать какие строки программы мы хотим посмотреть, можно воспользоваться командой `l [номер строки (начало), номер строки (конец)]`. Запятая в команде обязательна. Команда выведет строки кода, даже если их количество превышает стандартное значение.
**Команда (gdb)**:
```
l 8, 17
l 1, 17
q
```
**Вывод в консоль**:
```
8	int main() {
9		int i = 7;
10		
11		printf("\n");
12		printf("%d\n", i);
13		printf("%d\n", myfunc('M', 9));
14		printf("\n");
15		
16		return 0;
17	}

1	#include <stdio.h> // ввод и вывод в консоль
2	
3	int myfunc(char symbol, int a) {
4		printf("%c\n", symbol);
5		return a;
6	}
7	
8	int main() {
9		int i = 7;
10		
11		printf("\n");
12		printf("%d\n", i);
13		printf("%d\n", myfunc('M', 9));
14		printf("\n");
15		
16		return 0;
17	}
```
- **Описание**: чтобы напечатать несколько строк кода, которые находятся после момента, в котором вы остановились, нужно воспользоваться командой `list [+количество строк]` или `list [-количество строк]`, чтобы напечатать строки после.
**Команды (gdb)**:
```
b 9
r
list -5
list +5
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11a8: file main.c, line 9.

Starting program: ...

Breakpoint 1, main () at main.c:9
9		int i = 7;

1	#include <stdio.h> // ввод и вывод в консоль
2	
3	int myfunc(char symbol, int a) {
4		printf("%c\n", symbol);
5		return a;
6	}
7	
8	int main() {
9		int i = 7;
10		

11		printf("\n");
12		printf("%d\n", i);
13		printf("%d\n", myfunc('M', 9));
14		printf("\n");
15		
16		return 0;
17	}

Continuing.

7
M
9

```
- **Описание**: команда `list [имя функции]` показывает часть кода с реализацией функции.
**Описание кода**: перенесём реализацию функции `myfunc()` в конец фала.
**Код на C**:
```c
int myfunc();

int main() {
	int i = 7;
	
	printf("\n");
	printf("%d\n", i);
	printf("%d\n", myfunc());
	printf("\n");
	
	return 0;
}

int myfunc() {
	printf("\n");
	return 9;
}
```
**Команды (gdb)**:
```sh
list myfunc
q
```
**Вывод в консоль**:
```
11		printf("\n");
12		
13		return 0;
14	}
15	
16	int myfunc() {
17		printf("\n");
18		return 9;
19	}
```

14. ставить `точку останова` *на функцию* или на строку *в файле*
- **Описание**: поставить точку останова можно и на определённую функцию. Для этого нужно использовать команду `break, brea, bre, br, b` и *указать* `имя функции` (например `myfunc`). Программа дойдёт до нужной функции и остановит свою работу перед исполнением первой строки кода в *теле функции*.
**Описание кода**: используем код из предыдущего пункта.
**Команды (gdb)**:
```sh
b myfunc
r
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11ad: file main.c, line 17.

Starting program: /home/.../main.out 

7

Breakpoint 1, myfunc () at main.c:17
17              printf("\n");

Continuing.

9

```
- **Описание**: продолжим, используя этот код. Ставить точки останова можно также в определённом файле. Для этого нужно указать `b [имя файла]:[номер строки]`.
**Команды (gdb)**:
```sh
b main.c:6
r
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1151: file main.c, line 6.

Starting program: ... 

Breakpoint 1, main () at main.c:6
6               int i = 7;

Continuing.

7

9

```

15. *убить процесс* запущенной программы
**Описание**: команда `kill` убивает процесс программы, которая запущена отладчиком. Перед выполнением команды отладчик попросит вас подтвердить действие (`y` - да, `n` - нет).
**Команды (gdb)**:
```sh
b 11
r
kill
y
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1198: file main.c, line 11.

Starting program: ... 

7

9

Breakpoint 1, main () at main.c:11
11              printf("\n");

Kill the program being debugged? (y or n) y
[Inferior 1 (process 3453) killed]
```

16. *поменять значение* переменной во время работы программы
**Описание кода**: это код из файла в папке `example-3`
**Код на C**:
```c
int main() {
	int i = 7;
	
	printf("\n");
	printf("%d\n", i);
	printf("\n");
	
	return 0;
}
```
- **Описание**: команда `set variable, set var [имя переменной] = [значение]` может изменить значение переменной прямо в процессе исполнения программы. Менять значение переменных также можно командой `print [имя переменной] = [значение]`. При изменении значения с помощью `print`, новое значение будет сразу выводиться.
**Команды (gdb)**:
```sh
b 7
r
p i
set var i = 10
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1186: file main.c, line 7.

Starting program: ...

Breakpoint 1, main () at main.c:7
7		printf("%d\n", i);
 
$1 = 7

Continuing.
10

```
- **Описание**: изменить значение переменной можно на выражение (например на `i + 10`). 
**Команды (gdb)**:
```sh
b 7
r
p i
set var i = i + 10
print i += 1
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1186: file main.c, line 7.

Starting program: ...

Breakpoint 1, main () at main.c:7
7               printf("%d\n", i);

$1 = 7


$2 = 18

Continuing.
18

```


17. установить `условие срабатывания` точки останова
**Описание**:  чтобы установить условие срабатывания точки останова, нужно дописать `if` (после `if` обязательно должен быть *пробел*, в условии пробелы необязательны), потом в скобках или без них само `условие`, в *таком же виде*, как мы его пишем *в коде*.
В этом *примере* видно, что точка останова *не сработала* и программа не остановилась, так как `условие` оказалось *ложным*.
**Команды (gdb)**:
```sh
b 7 if (i != 7)
r
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1186: file main.c, line 7.

Starting program: ...

7

```

18. *игнорировать* некоторое количество попаданий в точку останова
**Описание кода**: используем программу из папки `example-6`, в которой точка останова будет в цикле
**Код на C**:
```c
int main() {
	int i = 7;
	
	printf("\n");
	for(int j = 0; j < 5; j++)
		printf("%d\n", i);
	printf("\n");
	
	return 0;
}
```
**Описание**: с помощью команды `ignore, ig [номер точки останова] [количество игнорирований]` можно *игнорировать* некоторое количество попаданий в точку останова. Дальше мы продолжаем работу программы дважды с помощью команды `c 2`
**Команды (gdb)**:
```sh
b 8
i b
ignore 1 3
r
c 2
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x118f: file main.c, line 8.

Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000000000000118f in main at main.c:8

Will ignore next 3 crossings of breakpoint 1.

Starting program: ...

7
7
7

Breakpoint 1, main () at main.c:8
8			printf("%d\n", i);

Will ignore next crossing of breakpoint 1.  Continuing.
7
7

```

19. под отладкой записывать значение по `указателю`
**Описание кода**: напишем код с указателями.
**Код на C**:
```c
int main() {
	int i = 7;
	int j = 9;
	int* iPtr = &i;
	iPtr = &j;
	
	printf("\n");
	printf("%d\n", *iPtr);
	printf("\n");
	
	return 0;
}
```
**Описание**: менять *значение по указателю* и менять *значение указателя* можно используя операцию взятия адреса `&` и разыменования `*`, а *команды* при этом остаются теми же: `print`, `set var`, `info locals` и т.п.
**Команды (gdb)**:
```sh
b 10
r
p iPtr
p &iPtr
set var *iPtr = 80
i locals
set var iPtr = &i
p iPtr
set var *iPtr = 70
i locals
c
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11cc: file main.c, line 10.

Starting program: ...


Breakpoint 1, main () at main.c:10
10		printf("%d\n", *iPtr);

$1 = (int *) 0x7fffffffde4c

$2 = (int **) 0x7fffffffde50

i = 7
j = 80
iPtr = 0x7fffffffde4c

$3 = (int *) 0x7fffffffde48

i = 70
j = 80
iPtr = 0x7fffffffde48

Continuing.
70

```

20. под отладкой просматривать все `поля структуры`  + менять поля структуры
**Описание кода**: создадим код со структурой
**Код на C**:
```c
typedef struct {
	int x, y;
	char name[20];
} T1;

int main() {
	T1 A = {11, 444, "Ionish"};
	
	printf("\n");
	printf("%d, %d, %s\n", A.x, A.y, A.name);
	printf("\n");
	
	return 0;
}
```
**Описание**: чтобы просмотреть *все поля структуры* достаточно воспользоваться командой `print [имя структуры]` или `info locals`, чтобы посмотреть поля структуры вместе с остальными локальными переменными.
Чтобы *посмотреть* конкретное *поле структуры*, можно использовать команду `print [имя структуры].[поле]`.
Чтобы *поменять* значение *поля* структуры, можно воспользоваться командой `set var [имя структуры].[поле] = [значение]`.
**Команды (gdb)**:
```sh
b 12
r
p A
p A.x
i locals
set var A.y = 555
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11da: file main.c, line 12.

Starting program: ...


Breakpoint 1, main () at main.c:12
12		printf("%d, %d, %s\n", A.x, A.y, A.name);

$1 = {x = 11, y = 444, name = "Ionish", '\000' <repeats 13 times>}

$2 = 11

A = {x = 11, y = 444, name = "Ionish", '\000' <repeats 13 times>}

Continuing.
11, 555, Ionish

```

21. под отладкой обращаться по `указателю на структуру`
**Описание кода**: добавим указатель на структуру.
**Код на C**:
```c
typedef struct {
	int x, y;
	char name[20];
} T1;

int main() {
	T1 A = {11, 444, "Ionish"};
	T1* sPtr = &A;
	
	printf("\n");
	printf("%d, %d, %s\n", sPtr->x, sPtr->y, sPtr->name);
	printf("\n");
	
	return 0;
}
```
**Описание**: команда `print *[указатель на структуру]` выводит поля структуры по указателю на неё.
Команда `p sPtr->x` выводит поле структуры по указателю на неё.
Команда `set var [указатель на структуру]->[поле] = [значение]` изменяет значение поля структуры по указателю на неё.
**Команды (gdb)**:
```sh
b 13
r
p sPtr
i locals
p *sPtr
p sPtr->x
set var sPtr->x = 6
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x5555555551e2: file main.c, line 13.

Starting program: ...


Breakpoint 1, main () at main.c:13
13		printf("%d, %d, %s\n", sPtr->x, sPtr->y, sPtr->name);

$1 = (T1 *) 0x7fffffffde30

A = {x = 11, y = 444, name = "Ionish", '\000' <repeats 13 times>}
sPtr = 0x7fffffffde30

$2 = {x = 11, y = 444, name = "Ionish", '\000' <repeats 13 times>}

$3 = 11

Continuing.
6, 444, Ionish

```

22. просматривать `массив` под отладкой и менять значение его элементов
**Описание кода**: напишем код с массивом.
**Код на C**:
```c
int main() {
	int k[] = {1, 2, 3, 44, 55};
	
	printf("\n");
	printf("%d\n", k[0]);
	printf("\n");
	
	return 0;
}
```
**Описание**: команда `print (имя массива)` выводит все значения массива. Также массив можно посмотреть командой `info locals`.
Команда `print (имя массива)[(номер элемента)]` выводит значение элемента массива, а команда `set var (имя массива)[(номер элемента)] = (значение)` меняет значение элемента массива.
**Команды (gdb)**:
```sh
b 7
r
p k
i locals
set var k[0] = 6
p k[0]
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11d1: file main.c, line 7.

Starting program: ...


Breakpoint 1, main () at main.c:7
7		printf("%d\n", k[0]);

$1 = {1, 2, 3, 44, 55}

k = {1, 2, 3, 44, 55}

$2 = 6

Continuing.
6

```

23. *пошагово* выполнять программу
**Описание кода**: напишем побольше кода.
**Код на C**:
```c
int myfunc() {
	return 9;
}

void myproc() {
	int b = 1;
	b += 5;
	printf("%d, %d\n", b, myfunc());
}

int main() {
	int i = 7;
	
	myproc();
	myproc();
	
	printf("\n");
	printf("Hello!\n");
	printf("%d\n", i);
	printf("%d\n", myfunc());
	printf("\n");
	
	return 0;
}
```
**Описание**: команда `next, n` выполняет следующую строчку кода *без захода в функцию*. Под функциями имеются в виду ваши самописные функции.
Постоянно вводить `next` не придётся, так как при нажатии `Enter` выполняется последняя введённая команда.
Команда `next [количество строк]` выполняет `next` несколько раз.
**Команды (gdb)**:
```sh
b main
r
n


n 5
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11e3: file main.c, line 14.

Starting program: ...

Breakpoint 1, main () at main.c:14
14		int i = 7;

16		myproc();

6, 9
17		myproc();

6, 9
19		printf("\n");

Hello!
7
9

25		return 0;

Continuing.
```

24. *пошагово* выполнять программу, входя в код `функций` и `процедур`
**Описание**: команда `step, s` выполняет следующую строчку кода *с заходом в функцию*.
Команда `step [количество строк]` выполняет `step` несколько раз.
**Команды (gdb)**:
```sh
b main
r
s

s 2

c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11e3: file main.c, line 14.

Starting program: ...

Breakpoint 1, main () at main.c:14
14		int i = 7;

16		myproc();

myproc () at main.c:8
8		int b = 1;

10		printf("%d, %d\n", b, myfunc());

5	}

Continuing.
6, 9
6, 9

Hello!
7
9

```

25. *выполнить* определённое количество `строк кода`
**Описание**: если нужно выполнить программу до какого-то момента, но точку останова ставить не хочется, можно использовать команду `until, u [номер строки/функция]`, которая дойдёт до определённой строки и остановит программу. `until` может принимать те же аргументы, что и точки останова.
**Команды (gdb)**:
```sh
b main
r
until 23
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11e3: file main.c, line 14.

Starting program: ...

Breakpoint 1, main () at main.c:14
14		int i = 7;

6, 9
6, 9

Hello!
7
9
main () at main.c:23
23		printf("\n");

Continuing.

```

26. посмотреть `стек вызовов` функций
**Описание**: команда `backtrace, where, bt` показывает вложенность функций на месте, в котором остановилась программа. Эта команда поможет узнать откуда вызывается то или иное действие.
**Команды (gdb)**:
```sh
b myfunc
r
bt
c 100
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1191: file main.c, line 4.

Starting program: ...

Breakpoint 1, myfunc () at main.c:4
4		return 9;

#0  myfunc () at main.c:4
#1  0x00005555555551b9 in myproc () at main.c:10
#2  0x00005555555551f4 in main () at main.c:16

Will ignore next 99 crossings of breakpoint 1.  Continuing.
6, 9
6, 9

Hello!
7
9

```

27. *узнать* `тип переменной`
**Описание кода**: 
**Код на C**:
```c
int main() {
	int i = 7;
	float j = 4.5;
	char name[] = "privet";
	
	printf("\n");
	printf("%d\n", i);
	printf("%g\n", j);
	printf("%s\n", name);
	printf("\n");
	
	return 0;
}
```
**Описание команд**: команда `ptype [имя переменной]` выводит тип переменной.
**Команды (gdb)**:
```sh
b 8
r
ptype i
ptype j
ptype name
ptype name[3]
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11e9: file main.c, line 8.

Starting program: ...

Breakpoint 1, main () at main.c:8
8		printf("\n");

type = int

type = float

type = char [7]

type = char

Continuing.

7
4.5
privet

```

28. ставить `точки останова` *относительно* текущего положения
**Описание**: команда `break [+/- количество строк]` ставит точку останова относительно текущего места остановки программы. При повторном запуске программы эти точки останова могут сбиваться, поэтому их лучше не использовать.
**Команды (gdb)**:
```sh
b 10
r
b -1
b +1
i b
c
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x120c: file main.c, line 10.

Starting program: ...

7

Breakpoint 1, main () at main.c:10
10		printf("%g\n", j);

Breakpoint 2 at 0x5555555551f3: file main.c, line 9.

Breakpoint 3 at 0x555555555233: file main.c, line 11.

Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x000055555555520c in main at main.c:10
	breakpoint already hit 1 time
2       breakpoint     keep y   0x00005555555551f3 in main at main.c:9
3       breakpoint     keep y   0x0000555555555233 in main at main.c:11

Continuing.
4.5

Breakpoint 3, main () at main.c:11
11		printf("%s\n", name);

Continuing.
privet

```

29. *выключать* и *включать* точки останова
**Описание**: команда `enable, en [номер точки останова]` *включает* отключённую точку останова.
Команда `disable, disa, dis [номер точки останова]` *отключает* точку останова.
В этих командах **номера** точек останова можно указывать *через тире*, чтобы указать *сразу несколько* точек.
**Команды (gdb)**:
```sh
b 9
b 11
r
i b
dis 1
dis 2
c
r
i b
en 1-2
r
c
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11f3: file main.c, line 9.

Breakpoint 2 at 0x1233: file main.c, line 11.

Starting program: ...


Breakpoint 1, main () at main.c:9
9		printf("%d\n", i);

Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00005555555551f3 in main at main.c:9
	breakpoint already hit 1 time
2       breakpoint     keep y   0x0000555555555233 in main at main.c:11

Continuing.
7
4.5
privet

[Inferior 1 (process 5302) exited normally]

Starting program: ...

7
4.5
privet

[Inferior 1 (process 5306) exited normally]

Num     Type           Disp Enb Address            What
1       breakpoint     keep n   0x00005555555551f3 in main at main.c:9
2       breakpoint     keep n   0x0000555555555233 in main at main.c:11

Starting program: ...


Breakpoint 1, main () at main.c:9
9		printf("%d\n", i);

Continuing.
7
4.5

Breakpoint 2, main () at main.c:11
11		printf("%s\n", name);

Continuing.
privet

```
- **Описание**: можно отключить или включить *сразу все* точки останова, указав `dis b` / `en b`. Отключена или включена точка останова *можно узнать* командой `info b`, смотря на *столбец* `Enb`, где `n` - это *выключенная* точка, а `y` - *включенная*.
**Команды (gdb)**:
```sh
b 9
b 11
dis b
i b
en b
i b
r
c

q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11f3: file main.c, line 9.

Breakpoint 2 at 0x1233: file main.c, line 11.

Num     Type           Disp Enb Address            What
1       breakpoint     keep n   0x00000000000011f3 in main at main.c:9
2       breakpoint     keep n   0x0000000000001233 in main at main.c:11

Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00000000000011f3 in main at main.c:9
2       breakpoint     keep y   0x0000000000001233 in main at main.c:11

Starting program: ...


Breakpoint 1, main () at main.c:9
9		printf("%d\n", i);

Continuing.
7
4.5

Breakpoint 2, main () at main.c:11
11		printf("%s\n", name);

Continuing.
privet

```

30. вывести `дизассемблер` программы
**Описание**: команда `disassemble` выводит *дизассемблер* программы и *указывает* на какой инструкции она *остановилась* знаком `=>`. Команда работает только, если программа запущена.
Если дизассемблер *не будет умещаться* в консоли, то команда выведет строку `--Type <RET> for more, q to quit, c to continue without paging--` (на `q` *прекратить* просмотр *дизассемблера*, на `Enter` продолжить просмотр, а нажав `с` - *показать сразу всё*).
**Команды (gdb)**:
```sh
b 11
r
disassemble
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1233: file main.c, line 11.

Starting program: ...

7
4.5

Breakpoint 1, main () at main.c:11
11		printf("%s\n", name);

Dump of assembler code for function main:
   0x00005555555551a9 <+0>:	endbr64 
   0x00005555555551ad <+4>:	push   %rbp
   0x00005555555551ae <+5>:	mov    %rsp,%rbp
   0x00005555555551b1 <+8>:	sub    $0x20,%rsp
   0x00005555555551b5 <+12>:	mov    %fs:0x28,%rax
   0x00005555555551be <+21>:	mov    %rax,-0x8(%rbp)
   0x00005555555551c2 <+25>:	xor    %eax,%eax
   0x00005555555551c4 <+27>:	movl   $0x7,-0x18(%rbp)
   0x00005555555551cb <+34>:	movss  0xe39(%rip),%xmm0        # 0x55555555600c
   0x00005555555551d3 <+42>:	movss  %xmm0,-0x14(%rbp)
   0x00005555555551d8 <+47>:	movl   $0x76697270,-0xf(%rbp)
   0x00005555555551df <+54>:	movw   $0x7465,-0xb(%rbp)
   0x00005555555551e5 <+60>:	movb   $0x0,-0x9(%rbp)
   0x00005555555551e9 <+64>:	mov    $0xa,%edi
   0x00005555555551ee <+69>:	call   0x555555555080 <putchar@plt>
   0x00005555555551f3 <+74>:	mov    -0x18(%rbp),%eax
   0x00005555555551f6 <+77>:	mov    %eax,%esi
   0x00005555555551f8 <+79>:	lea    0xe05(%rip),%rax        # 0x555555556004
   0x00005555555551ff <+86>:	mov    %rax,%rdi
   0x0000555555555202 <+89>:	mov    $0x0,%eax
   0x0000555555555207 <+94>:	call   0x5555555550b0 <printf@plt>
   0x000055555555520c <+99>:	pxor   %xmm1,%xmm1
--Type <RET> for more, q to quit, c to continue without paging--
   0x0000555555555210 <+103>:	cvtss2sd -0x14(%rbp),%xmm1
   0x0000555555555215 <+108>:	movq   %xmm1,%rax
   0x000055555555521a <+113>:	movq   %rax,%xmm0
   0x000055555555521f <+118>:	lea    0xde2(%rip),%rax        # 0x555555556008
   0x0000555555555226 <+125>:	mov    %rax,%rdi
   0x0000555555555229 <+128>:	mov    $0x1,%eax
   0x000055555555522e <+133>:	call   0x5555555550b0 <printf@plt>
=> 0x0000555555555233 <+138>:	lea    -0xf(%rbp),%rax
   0x0000555555555237 <+142>:	mov    %rax,%rdi
   0x000055555555523a <+145>:	call   0x555555555090 <puts@plt>
   0x000055555555523f <+150>:	mov    $0xa,%edi
   0x0000555555555244 <+155>:	call   0x555555555080 <putchar@plt>
   0x0000555555555249 <+160>:	mov    $0x0,%eax
   0x000055555555524e <+165>:	mov    -0x8(%rbp),%rdx
   0x0000555555555252 <+169>:	sub    %fs:0x28,%rdx
   0x000055555555525b <+178>:	je     0x555555555262 <main+185>
   0x000055555555525d <+180>:	call   0x5555555550a0 <__stack_chk_fail@plt>
   0x0000555555555262 <+185>:	leave  
   0x0000555555555263 <+186>:	ret    
End of assembler dump.

Continuing.
privet

```

31. *отслеживать* изменение значения `переменной`
**Описание кода**: напишем код для примера
**Код на C**:
```c
void ChageInt(int* iPtr) {
	*iPtr += 5;
}

int main() {
	int i = 7;
	int* iPtr = &i;
	
	ChageInt(iPtr);
	
	printf("\n");
	printf("i = %d\n", i);
	
	ChageInt(iPtr);
	i++;
	
	printf("i = %d\n", i);
	printf("\n");
	
	return 0;
}
```
**Описание команд**: команда `display, disp [имя переменной]` позволяет следить за *изменением* значения переменной, выводя информацию о ней при каждом исполнении программы.
У каждой *отслеживающейся переменной* есть `свой номер`. Посмотреть какие *переменные отслеживаются* можно командой `i disp`.
Удалить слежку можно командой `del disp [номер переменной]` или `undisplay [номер переменной]`.
**Команды (gdb)**:
```sh
b 9
r
disp i
n




i disp
del disp 1
i disp
n



c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11c9: file main.c, line 9.

Starting program: ...

Breakpoint 1, main () at main.c:9
9		int* iPtr = &i;

1: i = 7

11		ChageInt(iPtr);
1: i = 7

13		printf("\n");
1: i = 12

14		printf("i = %d\n", i);
1: i = 12

i = 12
16		ChageInt(iPtr);
1: i = 12

17		i++;
1: i = 17

Auto-display expressions now in effect:
Num Enb Expression
1:   y  i

There are no auto-display expressions now.

19		printf("i = %d\n", i);

i = 18
20		printf("\n");

22		return 0;

23	}

Continuing.
```

32. поставить `точку наблюдения` (watchpoint)
Связанные команды:
- команда `watch [имя переменной]` останавливает программу при изменении указанной переменной
- команда `rwatch [выражение]` останавливает программу при чтении выражения
- команда `awatch [выражение]` останавливает программу при чтении или записи выражения
- команда `info watch` выводит информацию обо всех *точках наблюдения*
- команда `info b` выводит информацию обо всех *точках останова* и *точках наблюдения*
*Удаление* точек наблюдения происходит *так же*, как и удаление точек останова:
- команда `clear, cl` удаляет точку останова *в текущей строке*
- команда `clear [имя файла]:[номер строки/имя функции]` удаляет точку останова в *указанном месте* файла
- команда `del` без параметров *удаляет все* точки останова
**Команды (gdb)**:
```sh
b 11
r
watch i
i b
n


del 2
i watch
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11d1: file main.c, line 11.

Starting program: ...

Breakpoint 1, main () at main.c:11
11		ChageInt(iPtr);

Hardware watchpoint 2: i

Num     Type           Disp Enb Address            What
1       breakpoint     keep y   0x00005555555551d1 in main at main.c:11
	breakpoint already hit 1 time
2       hw watchpoint  keep y                      i


Hardware watchpoint 2: i

Old value = 7
New value = 12
ChageInt (iPtr=0x7fffffffde4c) at main.c:5
5	}

main () at main.c:13
13		printf("\n");


14		printf("i = %d\n", i);

No watchpoints.

Continuing.
i = 12
i = 18

```

33. *завершить выполнение* текущей функции и выйти из неё
**Описание кода**: этот код из папки `example-23`
**Код на C**:
```c
int myfunc() {
	return 9;
}

void myproc() {
	int b = 1;
	b += 5;
	printf("%d, %d\n", b, myfunc());
}

int main() {
	int i = 7;
	
	myproc();
	myproc();
	
	printf("\n");
	printf("Hello!\n");
	printf("%d\n", i);
	printf("%d\n", myfunc());
	printf("\n");
	
	return 0;
}
```
**Описание команд**: команда `finish, fin` выполняет программу до возврата из текущей функции и останавливает программу. После этого `возвращаемое значение` функции печатается и *помещается* в `журнал значений` (например `$1 = 9`). Если функция ничего не возвращает, то, конечно, `fin` ничего не вернёт.
**Команды (gdb)**:
```sh
b 22
r
s
fin
n
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x1230: file main.c, line 22.

Starting program: ...
6, 9
6, 9

Hello!
7

Breakpoint 1, main () at main.c:22
22		printf("%d\n", myfunc());

myfunc () at main.c:4
4		return 9;

Run till exit from #0  myfunc () at main.c:4
0x000055555555523a in main () at main.c:22
22		printf("%d\n", myfunc());
Value returned is $1 = 9

9
23		printf("\n");

Continuing.

```

34. отладка в `layout` режиме + как выйти из него
**Описание**: `la, lay, layout` - это TUI режим интерфейса на основе `curses`, которые предоставляет удобный просмотрщик кода, ассемблерных инструкций и регистров.
Команды для смены режимов:
- `layout [asm]` - просмотреть *ассемблер* кода
- `layout [src]` - просмотреть *исходный код* программы
- `layout [regs]` - просмотреть *регистры*
- `layout [split]` - посмотреть *два TUI окна* одновременно
- `layout [next]` - применить *следующий* макет TUI
- `layout [prev]` - применить *предыдущий* макет TUI
- `focus, fs [TUI режим]`- при нескольких открытых окнах фокусирует внимание на выбранном (например на `asm`). Можно использовать аргументы `next, n` и `prev, p`.
Чтобы *войти* или *выйти* из режима `layout` нужно нажать комбинацию клавиш: `Ctrl`+`x`+`a`.
С помощью команды `tui [disable, dis]` можно *отключить* `layout` режим и *включить* с помощью`tui [enable, en]`. При этом настройки TUI сохраняются.
**Команды (gdb)**:
```sh
b 19
r
la src
n


tui dis
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11fe: file main.c, line 19.

Starting program: ...
6, 9
6, 9

Breakpoint 1, main () at main.c:19
19		printf("\n");

Continuing.
9

```

35. *пошагово* выполнять ассемблерные инструкции
**Описание**: `stepi, si`/`nexti, ni` - принцип такой же, как у `step`/`next`, но программа выполняется по *ассемблерным инструкциям*. Имеет смысл использовать только вместе с `layout` режимом.
**Команды (gdb)**:
```sh
b 19
r
la asm
ni



tui dis
c
q
```
**Вывод в консоль**:
```
Breakpoint 1 at 0x11fe: file main.c, line 19.

Starting program: ...
6, 9
6, 9

Breakpoint 1, main () at main.c:19
19		printf("\n");

Continuing.
Hello!
7
9

```

36. *подключаться* к запущенному `процессу` для отладки
- Чтобы подключиться к *уже запущенному* процессу, нужно указать `исполняемый файл`, скомпилированный с *отладочной информацией* и указать `ID процесса` (то есть `pid`).
**Пример**:
```
gdb ./mycprog -pid 11786
```
- Но процессы в Linux *защищены* от подключения, поэтому *вылечить отказ* в доступе можно так (эту команду нужно вводить при *каждом запуске* системы):
```sh
echo 0 | sudo tee /proc/sys/kernel/yama/ptrace_scope
```
*Включить защиту* обратно можно так:
```sh
echo 1 | sudo tee /proc/sys/kernel/yama/ptrace_scope
```
Подключиться, не меняя никаких файлов, можно имея `root права`:
```sh
sudo gdb ./mycprog -pid 11786
```
- Узнать `pid` процесса можно так:
```sh
pgrep [имя исполняемого файла]
```
Или, например, так (пример с запуском gdb и проверкой существования `pid`):
```sh
program_name=[имя исполняемого файла]
pid=$(pgrep $program_name)
pgrep_result="$?"
if [ $pgrep_result = "0" ]; then
	gdb -silent -pid $pid
fi
```
При подключении к процессу исходный код будет доступен только тогда, когда программа была остановлена точкой останова и выполняется пошагово.

37. *дополнительные* команды
- Команда `start` *заменяет* выполнение двух команд: `b main`+`r`. При этом аргументами команды также могут стать *файлы* (используя `<` и т.д.).
- Если отображение в консоли *сбилось* и его нужно перерисовать, то вызовете команду `ref, refresh`.

### Конец
